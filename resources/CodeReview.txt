      In order to force our code to work with our upstream provider’s, we changed their function names to match ours, and we also added functionality to our implementation to account for the functions that we did not originally add.  We changed our class names and interface names to match theirs inside the functions, not our actual class names.      Their views made correct use of private variables and private methods.  Their methods are mostly overridden, and accordingly do not need Javadoc comments, however there are numerous methods in this class which do not have @override and do not have a Javadoc.  Additionally, The Mock Receiver, Midi Device, and the Composite view implementations do not have Javadoc comments.        Only one of pause() or setPause() are required because either one of  these could be very easily used to emulate the behavior of the other with isPaused().  The methods name’s in most classes are well named.  In the console view, the makeRow() method technically doesn’t create a string representation, but creates a stringBuilder which contains the string representation.  The string builder isn’t a string representation but can create on with toString().        It would be helpful if viewModel() had a generic interface to help prevent minor required changes to the code here.  We needed the note class to determine what getNoteValue() did.  We would not have needed it had it been named more descriptively.  However, other than this, most of the changes were simply renaming methods and changing the import statements.  The main exception to the rule is that we had to add a view Factory which was less than ideal.  In general, their implementation was easy to add to and worked well with our code.